import com.xpn.xwiki.api.Context
import com.xpn.xwiki.api.Document
import com.xpn.xwiki.api.XWiki
import com.xpn.xwiki.plugin.mailsender.MailSenderPluginApi
import com.xpn.xwiki.web.XWikiMessageTool
import groovy.json.JsonSlurper
import org.apache.commons.lang.RandomStringUtils
import org.apache.commons.logging.Log
import org.apache.commons.logging.LogFactory
import org.apache.http.HttpResponse
import org.apache.http.client.HttpClient
import org.apache.http.client.methods.HttpGet
import org.apache.http.client.methods.HttpPost
import org.apache.http.entity.StringEntity
import org.apache.http.impl.client.DefaultHttpClient
import org.apache.http.util.EntityUtils
import org.brickred.socialauth.AuthProvider
import org.brickred.socialauth.AuthProviderFactory
import org.brickred.socialauth.Permission
import org.brickred.socialauth.Profile
import org.brickred.socialauth.util.SocialAuthUtil

import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

public class SocialLoginToolGroovy {
    // the properties are static... it means they are loaded with the compilation of the groovy class
    private static Properties properties = null;

    private XWiki xwiki = null;
    private Context context = null;
    HttpServletRequest request = null;
    private XWikiMessageTool msg = null;
    private List errors = new ArrayList();
    String providerId = null;
    String city="", state="", country="";
    List warningFields=new ArrayList(), okFields=new ArrayList();
    String username, password, firstName, lastName, email, email_confirmation, memberType, postalCode="", longitude="", latitude="", agree;
    String validKey = null;
    String nowTarget = null;
    boolean hasReadProviderProfile = false;
    Object validation;
    def targets;
    def profile = null;
    boolean hasAuthenticated = false;

    /**
     * A switch to set if the registration of a new user
     * should skip the creationForm and try to guess values for the new
     * user
     */
    boolean autoCreateUser = false

    MailSenderPluginApi mailsender = null;


    Log LOG = LogFactory.getLog("groovyPages.SocialLogin");

    public String init(XWiki xwiki, Context context, HttpServletRequest request, XWikiMessageTool msg, Object targets) {
        this.xwiki= xwiki;
        this.context = context;
        this.request = request;
        this.msg = msg;
        this.targets = targets;
        if(properties==null) {
            properties = new Properties();
            properties.load(
                    request.getSession(true).getServletContext().
                            getResourceAsStream("/WEB-INF/oauth_consumer.properties"));
        }
        validation = xwiki.parseGroovyFromPage("Registration.Validation");
        validation.init(xwiki, errors, warningFields, okFields);

        LOG.info("Initted");
        return "";
    }

    public void grabFrom(Object other1) {
        if(other1==null) return;
        if(!(other1 instanceof SocialLoginToolGroovy)) {
            System.out.println("tograb is not correct: \"" + other1 + "\" of class " + other1.getClass() );
            return;
        }
        SocialLoginToolGroovy other = other1;
        System.out.println("SocialLoginToolGroovy  grabbing into " + this + " being prepopulated from " + other);
        this.hasReadProviderProfile = other.hasReadProviderProfile
        this.firstName = other.firstName;
        this.lastName = other.lastName;
        this.email = other.email;
        this.agree = other.agree;
        this.city = other.city;
        this.state = other.state;
        this.country = other.country;
        this.memberType = other.memberType;
        this.longitude = other.longitude;
        this.latitude = other.latitude;
        this.postalCode = other.postalCode;

        this.password = other.password;
        this.providerId = other.providerId;
        this.username = other.username;

        this.errors = other.errors;
        this.warningFields = other.warningFields;
        this.okFields = other.okFields;
        this.nowTarget = other.nowTarget;

        this.autoCreateUser = other.autoCreateUser

        System.out.println("AutoCreateUser: " + this.autoCreateUser)
        System.out.println("Errors: " + errors);
        System.out.println("WarningFields: " + warningFields);
        System.out.println("okFields: " + okFields);
    }

    public String authenticateUser(Document userDoc) {
        try {
            System.out.println("Authenticating user " + userDoc);
            if(userDoc==null) return null;
            context.context.put("ajax",true);
            xwiki.checkAuth(userDoc.fullName, userDoc.get("XWiki.XWikiUsers").get("password").value, "false")
            this.toLogView("/join/"+( providerId==null ? "inCurriki" : providerId) +"/login");
            nowTarget = getRedirectTarget(true);
            this.hasAuthenticated  = true;
            //nowTarget = request.session.getAttribute("xredirect");
            return "redirectOnTop";
            //def xwikiAuthenticator = xwiki.getXWiki().getAuthService(); //.@authenticators.get('xwiki')
            //def psm = xwikiAuthenticator.@persistentLoginManager;
            // psm.rememberLogin(request, response, userDoc.fullName, password)
            //xwikiAuthenticator.authenticate(userDoc.fullName, password, context.context);
            //xwiki.getXWiki().getAuthService().authenticate(userDoc.fullName, password, context.context)
        } catch (Exception ex) {
            LOG.warn("Trouble at authenticating: ", ex);
            errors.add(msg.get('xwiki.socialLogin.genericError', [ex.message]));
            return "error";
        };
    }

    public List getErrors() {
        return errors;
    }

    /**
     * Initiate the OAuth dance with the requested provider
     */
    public String bounceToProvider(HttpServletResponse response) {
        try {
            System.out.println("Bouncing to Provider " + request.provider);
            AuthProvider provider = AuthProviderFactory.getInstance(request.provider, properties);
            //println provider; // ???
            String maybeRedirect = request.getParameter("xredirect");
            if(maybeRedirect!=null && maybeRedirect.length()>0)
                maybeRedirect = "&xredirect=" +request.getParameter("xredirect");
            else maybeRedirect = "";
            String maybeXpage="";
            //if(request.framed=="true")
            maybeXpage="&xpage=popup&tempskin=curriki8";

            String targetUrl = "http://" + xwiki.getXWiki().Param('curriki.system.hostname', 'broken-url') +"/xwiki/bin" +
                    request.getPathInfo()  + '?callbackCurriki=1' + maybeXpage //+ maybeRedirect ;

            // Keep the autoCreateUser flag even when bouncing the provider, so it comes back with the providers answer
            if(autoCreateUser) targetUrl += "&autoCreateUser=" + autoCreateUser;

            // Keep the memberType request parameter over the bounce
            memberType = request.getParameter("member_type")
            if(memberType != null) targetUrl += ("&member_type=" + memberType)

            provider.setPermission(Permission.AUTHENTICATE_ONLY);
            String url = provider.getLoginRedirectURL(targetUrl);
            System.out.println("Redirecting to " + url);

            // Store in session
            request.session.setAttribute("org.brickred.socialauth.AuthProvider", provider);
            request.session.setAttribute("org.brickred.socialauth.AuthProvider.hint", request.provider);
            response.sendRedirect(url);
            return "nothing";


            def space = xwiki.getDocument("Group_SampleCurrikiGeometryCourse.WebPreferences");
            println("Space found: " + space);
            println("* topic: " + space.getObject("XWiki.CurrikiSpaceClass").getProperty("topic").value);
            println("* topic class " + space.getObject("XWiki.CurrikiSpaceClass").getProperty("topic").value.getClass());
            println("* level: " + space.getObject("XWiki.CurrikiSpaceClass").getProperty("educationLevel").value);



        } catch (Exception ex) {
            LOG.warn("Generic error at bounce to provider.", ex);
            errors.add(msg.get('registration.genericError', [ex.message]));
            return "error";
        };
    }

    /**
     * We've got a response from the provider, let's treat it
     */
    public String processAuthReturn() {

        try {
            // get the provider back from session
            AuthProvider providerObj = request.session.getAttribute("org.brickred.socialauth.AuthProvider");
            this.providerId = request.session.getAttribute("org.brickred.socialauth.AuthProvider.hint");
            LOG.info("Welcoming from provider " + providerId);

            // verify the authentication
            LOG.info("Verifying " + providerObj + " for provider " + providerId);

            this.autoCreateUser = request.getParameter("autoCreateUser") == "true"

            try {
                if(request.error!='access_denied')
                    profile = providerObj.verifyResponse(SocialAuthUtil.getRequestParametersMap(request))
                LOG.info("obtained profile: " + profile);
            } catch (Exception ex) { LOG.warn("Error while verifing response", ex); }
            if(profile==null) {
                LOG.info("Refused authorization.");
                return "refused";
            }

            // Search for this profile id in database, find user
            String query =", BaseObject userObj, BaseObject socialLoginObj, StringProperty provider, StringProperty profileId where " +
                    " userObj.className='XWiki.XWikiUsers' and doc.web='XWiki' and doc.fullName=userObj.name " +
                    " and socialLoginObj.className='XWiki.SocialLoginProfileClass' and " +
                    " doc.fullName=socialLoginObj.name and " +
                    " provider.id.id = socialLoginObj.id and profileId.id.id = socialLoginObj.id and " +
                    " provider.name='provider' and profileId.name='validatedId' and provider.value='"+providerId+"' and profileId.value='"+profile.validatedId+"'";
            System.out.println("Querying: " + query);
            List userDocs = xwiki.searchDocuments(query,30,0);
            //original: XWQL: from doc.object(XWiki.XWikiUsers) as user, doc.object(XWiki.SocialLoginProfileClass) as profile where profile.provider = '""" + provider + "' and profile.validatedId = '" + profile.validatedId + "'")

            System.out.println("Found userDocs: " + userDocs);
            for (result in userDocs) {
                if(result==null) continue;
                Document userDoc = xwiki.getDocument(result)
                updateUserDoc(userDoc, false); // We dont merge the docs here
                System.out.println("Doc: " + result + " of class " + result.getClass());
                authenticateUser(userDoc)
            }

            if(userDocs==null || userDocs.isEmpty()) {
                // Not authenticated/redirected yet ? -> You must be new here
                // You will have to pick-up a username and dad will create an account for you

                // Store the social profile in the session
                request.session.setAttribute("org.brickred.socialauth.Profile", profile);
                LOG.warn("Received from " + providerId + " profile " + profile + ".");


                readProviderProfile();
                def validation = xwiki.parseGroovyFromPage("Registration.Validation");
                validation.init(xwiki, errors, warningFields, okFields);
                if(!validation.isValidEmail(((Profile)profile).email, false)) {
                    if(validation.foundAccountName) {
                        validation.zapErrors();
                        mergeAccountWithProfile(profile, validation.foundAccountName, providerId);
                        request.session.setAttribute("header.message","login.register.header.account-is-merged." + providerId);
                        return "backFromAuthorization";
                    }
                }else if(autoCreateUser) {
                    // Automatically register user
                    this.toLogView("/xwiki/bin/view/MembershipDrive/LandingPage/UserAutoRegistered")
                    return tryCreateNewProfile();
                } else {
                    // take to the display of the form to create the username
                    nowTarget = "/xwiki/bin/view/Registration/SocialLogin?xpage=popup&tempskin=curriki8&xaction=creationForm"
                    return "backFromAuthorization";
                }

            } else {
                // final step, login worked, existing user
                def afterLogin = targets!=null? targets.afterLogin : request.getSession().getAttribute("xredirect");
                nowTarget = "/xwiki/bin/view/Registration/JumpToTop?xpage=plain&redir=" + afterLogin;
                System.out.println("Redirecting to " + afterLogin+ " through a redirectOnTop");
                return "backFromAuthorization";
            }

        } catch (Exception ex) {
            ex.printStackTrace();
            errors.add(msg.get('xwiki.socialLogin.genericError', [ex.message]));
            return "error";
        };
    }


    public void readProviderProfile() {
        if(hasReadProviderProfile) return;
        hasReadProviderProfile = true;
        profile = request.session.getAttribute("org.brickred.socialauth.Profile");
        providerId = request.session.getAttribute("org.brickred.socialauth.AuthProvider.hint");
        firstName = profile.getFirstName();
        lastName = profile.getLastName();
        email = profile.getEmail();
        city = profile.location;
        //state = profile.state;
        country  = profile.country;

        username = profile.displayName;
        if(username==null || username=='') {
            int p = email.indexOf('@');
            username = email.substring(0,p);
            username = username.replaceAll("[^a-zA-Z0-9]","");
            username = username.replaceAll("_","").replaceAll("__","");
            if(!validation.isValidUsername(username, false)) {
                int i=0;
                while(i<20) {
                    if(validation.isValidUsername(username + i, false)) break
                    i++;
                }
                username = username +i;
            }
        }
    }


    /**
     * We've got a response from the provider, let's treat it
     */
    public String processCleverComAuthArrival() {

        try {

            // perform scenario at https://clever.com/developers/docs#identity-api-sso-oauth2-flow-section
            String providerId = "clever.com";
            LOG.info("Welcoming from provider " + providerId);
            DefaultHttpClient client = new DefaultHttpClient();
            HttpPost post = new HttpPost(properties.getProperty("clever.com.tokenFetchURL"));
            post.setHeader("Authorization", "Basic " + properties.getProperty("clever.com.basic.auth"));
            post.setEntity(new StringEntity("{" +
                    " \"code\": \""+ request.code + "\",\n" +
                    "  \"grant_type\": \"authorization_code\",\n" +
                    "  \"redirect_uri\": \"https://" + xwiki.curriki.getPublicCurrikiConfig('hostname', 'missing-curriki.system.hostname-property-in-config') + "/xwiki/bin/view/Registration/SocialLogin\"\n" +
                    "}","application/json","utf-8"));
            HttpResponse response = client.execute(post);
            String result = EntityUtils.toString(response.getEntity());
            if (response.getStatusLine().getStatusCode() != 200){
                //TODO: get rid of this unpretty illegal state and show a defined error to the user!?
                throw new IllegalStateException("Received wrong http status with Http response (StatusCode: " + response.getStatusLine().getStatusCode() + "value:" + result + ".");
            }

            // "redeem code" convert code to token
            def obj = new JsonSlurper().parseText(result);
            String token = obj.access_token;
            LOG.warn("YAY WE GOT A TOKEN");

            // fetch the info
            HttpGet get = new HttpGet(properties.getProperty("clever.com.apiURL"));
//            client.getParams().setAuthenticationPreemptive(false);
            get.addHeader("Authorization", "Bearer ${token}");
            response = client.execute(get);
            def cleverComProfile = (new JsonSlurper().parseText(EntityUtils.toString(response.getEntity()))).data;

            // Search for this profile id in database, find user
            String queryForSocialProfileValidatedId =", BaseObject userObj, BaseObject socialLoginObj, StringProperty provider, StringProperty profileId where " +
                    " userObj.className='XWiki.XWikiUsers' and doc.web='XWiki' and doc.fullName=userObj.name " +
                    " and socialLoginObj.className='XWiki.SocialLoginProfileClass' and " +
                    " doc.fullName=socialLoginObj.name and " +
                    " provider.id.id = socialLoginObj.id and profileId.id.id = socialLoginObj.id and " +
                    " provider.name='provider' and profileId.name='validatedId' and provider.value='clever.com"+
                    "' and profileId.value='"+cleverComProfile.id+"'";
            System.out.println("Querying: " + queryForSocialProfileValidatedId);
            List userDocs = xwiki.searchDocuments(queryForSocialProfileValidatedId,30,0);


            System.out.println("Found userDocs for SocialProfile validatedId: " + userDocs);
            // case with existing email
            if(userDocs!=null && !userDocs.isEmpty()) {
                // already exists?
                for (String x in userDocs) {
                    if(x==null) continue;
                    Document userDoc = xwiki.getDocument(x)
                    System.out.println("Doc: " + result + " of class " + result.getClass());
                    authenticateUser(userDoc);
                }
            } else if(userDocs==null || userDocs.isEmpty()) {
                // Not authenticated/redirected yet ? -> You must be new here
                LOG.warn("Received from " + providerId + " profile " + cleverComProfile + ".");

                // gather profile info
                if(hasReadProviderProfile) return;
                hasReadProviderProfile = true;
                if(cleverComProfile.name){
                    firstName = cleverComProfile.name.first;
                    lastName = cleverComProfile.name.last;
                }
                email = cleverComProfile.email;
                if(cleverComProfile.location){
                    city = cleverComProfile.location.city;
                    state = cleverComProfile.location.state;
                    postalCode = cleverComProfile.location.zip;
                    latitude = cleverComProfile.location.lat;
                    longitude = cleverComProfile.location.long;
                }
                country  = "US"; // profile.get("location.country")
                password = RandomStringUtils.randomAlphanumeric(8)
                username = generateUserNameFromSocialProfile();

                // Search for this email in database, find user
                String queryUserDocsForUserObjectEmail =", BaseObject userObj, StringProperty email where " +
                        " userObj.className='XWiki.XWikiUsers' and doc.web='XWiki' and doc.fullName=userObj.name and" +
                        " email.id.id = userObj.id and email.value = '" + cleverComProfile.email + "'";
                System.out.println("Querying: " + queryUserDocsForUserObjectEmail);
                List userDocsForEmail = xwiki.searchDocuments(queryUserDocsForUserObjectEmail,30,0);

                // Either create the new user or use the user for the existing email, if there is exactly one
                Document userDoc = null;
                if (userDocsForEmail.size() == 0 || email == null || email == "") {
                    System.out.println("No user for existing email address either -> create a new user doc")
                    userDoc = createUserDoc();
                }else if(userDocsForEmail.size() == 1){
                    System.out.println("Found userDocs for existing email address: " + userDocs);
                    userDoc = xwiki.getDocument(userDocsForEmail.get(0))
                } else {
                    //TODO: get rid of this unpretty illegal state and show a defined error to the user!?
                    // Well what if we find more than one?? For now we fail, otherwise we potentially authenticate a wrong user
                    throw new IllegalStateException("Duplicate email address for user profiles... " + cleverComProfile.email);
                }

                // now create the social-login object
                def socialProfile = userDoc.getObject('XWiki.SocialLoginProfileClass', true)
                socialProfile.set('provider', providerId)
                socialProfile.set('fullName', "XWiki."+username);
                socialProfile.set('firstName', firstName)
                socialProfile.set('lastName', lastName)
                socialProfile.set('displayName', firstName + " " + lastName)
                socialProfile.set('email', email)
                socialProfile.set('gender', cleverComProfile.gender)
                //socialProfile.set('dob', profile.dob) !!! This line raised an error while logging in via facebook, this attribute seems not to be there anymore
                socialProfile.set('validatedId', cleverComProfile.id)
                socialProfile.set('country', country)

                def socialPrefs = userDoc.getObject('XWiki.SocialLoginClass', true)
                socialPrefs.set('preferred_provider', providerId)

                userDoc.saveWithProgrammingRights();
                authenticateUser(userDoc)
            }

            // Always redirect to the advanced search page.
            nowTarget = "/xwiki/bin/view/Search/WebHome";
            System.out.println("Redirecting to /xwiki/bin/view/Search/WebHome through a redirectOnTop");
            return "redirectOnTop";

        } catch (Exception ex) {
            ex.printStackTrace();
            errors.add(msg.get('xwiki.socialLogin.genericError', [ex.message]));
            return "error";
        };
    }

    private String generateUserNameFromSocialProfile(String proposedUserName) {
        String username = "";
        // Check if the given name is okay, if yes return it.
        if(proposedUserName != null && proposedUserName != "" && validation.isValidUsername(proposedUserName, false)){
            username = proposedUserName

        // If not generate one
        } else {
            // From the email
            if (email != null && email != "" && email.indexOf('@') != -1){
                username = email.substring(0, email.indexOf('@'));

            // Or the firstname
            } else if (firstName != null && firstName != "") {
                username = firstName;

            // Or just a random one
            } else {
                username = RandomStringUtils.randomAscii(8);
            }
            username = username.replaceAll("[^a-zA-Z0-9]", "");
            username = username.replaceAll("_", "").replaceAll("__", "");
            username = username.replaceAll(" ", "")
            if (!validation.isValidUsername(username, false)) {
                int i = 0;
                while (i < 100) {
                    if (validation.isValidUsername(username + i, false)) break
                    i++;
                }
                username = username + i;
            }
        }
        return username;
    }

    /**
     * Create a new user profile from the social profile result
     */

    public String tryCreateNewProfile() {
        return updateUserDoc(null, false); //Nothing to merge
    }

    public String updateUserDoc(Document preExistingUserDoc, isMerging) {
        if(profile==null) profile = request.session.getAttribute("org.brickred.socialauth.Profile")
        String provider = request.session.getAttribute("org.brickred.socialauth.AuthProvider.hint");
        boolean isNew = preExistingUserDoc == null;
        if(isNew) LOG.info("Trying to create new profile from provider " + provider);
        else LOG.warn("Updating doc " + preExistingUserDoc + " with info from provider " + provider);


        if(isNew) {
            if(username==null || username=='') {
                username = request.username;
            }
        } else {
            username = preExistingUserDoc.getName();
        }

        firstName = profile.firstName;
        lastName = profile.lastName;
        email = profile.email;
        city = profile.location;
        country = profile.country;

        if(isNew && autoCreateUser) {
            password = RandomStringUtils.randomAlphanumeric(8)
        } else {
            password = request.password;
        }

        memberType = request.getParameter("member_type");
        if(memberType==null) memberType="-";

        if(request.getParameter("country")) country= request.getParameter("country");
        if(request.getParameter("city")) city  = request.getParameter("city");
        if(request.getParameter("state")) state = request.getParameter("state");
        if(request.getParameter("postalCode"))    postalCode = request.getParameter("postalCode");
        if(request.getParameter("longitude"))     longitude = request.getParameter("longitude");
        if(request.getParameter("latitude"))      longitude = request.getParameter("latitude");


        boolean passed = validation.isValidEmail(email, true);
        // This is not active on GPS since the social auth does not need this honeypot field
        // passed = validation.isValidEmailConfirmation(email_confirmation, true) & passed;
        passed = validation.isValidUsername(username, true) && passed;
        passed = validation.isValidPassword(password, true) && passed;
        passed = validation.isValidMemberType(memberType, true) && passed;
        passed = validation.isValidAgree(request.agree, true && autoCreateUser != true) && passed;
        passed = validation.isValidFirstName(firstName, true) && passed;
        passed = validation.isValidLastName(lastName, true) && passed;
        passed = validation.isValidLocation(country, postalCode, city, state, longitude, latitude, ( !isMerging && !autoCreateUser ) ) && passed;

        System.out.println("Validation Passed? " + passed);
        if(!passed) System.out.println(validation.errors.size() + " Validation Errors (Merging is "+ isMerging +"): " + validation.errors);
        if ( passed || isMerging || (validation.errors.size() == 0 && autoCreateUser) ) {
            // Everything clear, let's proceed

            /* def propMap = new HashMap();
            propMap.put("active", "1")
            propMap.put("email", profile.email)
            propMap.put("first_name", profile.firstName)
            propMap.put("last_name", profile.lastName)
            propMap.put("password", password)
            System.out.println("Obtained record: " + profile.properties) */

            //request.getParameterMap().put("xwikiname",userDocName);
            //request.getParameterMap().put("XWiki.XWikiUsers_0_password",password);



            Document userDoc;
            if(isNew) userDoc = createUserDoc();
            else userDoc = preExistingUserDoc;

            def userobj = userDoc.getObject("XWiki.XWikiUsers");
            userobj.set("active", "1");
            userobj.set("email_undeliverable", "0");


            createSocialLoginProfileObject(profile, userDoc, provider);
            tryToAddProfilePictureFromProfile(profile.profileImageURL, userDoc, userobj);
//            //tryToAddProfilePictureFromGoogle();
            userDoc.saveWithProgrammingRights(msg.get('xwiki.socialLogin.updatedSocialProfile'), true)

            System.out.println("New profile created and saved: " + userDoc);

            // Send the correct confirmation email
            sendCorrectConfirmationEmail(isMerging, autoCreateUser);

            String view = authenticateUser(userDoc);
            if(view=="redirectOnTop" && !autoCreateUser) return "pleaseDonate";
            else return view;
        }
        else {
            System.out.println("New profile not created!");
            if (!username || username == '')
                errors.add(msg.get('join.error.username'));
            else if (xwiki.exists('XWiki.' + username))
                errors.add(msg.get('join.error.login_not_unique'));
            if(!errors.isEmpty())
                return "creationForm";
            else return null;
        }
    }

    public boolean isCorporateAccount() {
        return 'corporation'==memberType;
    }

    private Document createUserDoc() {
        def userDoc = new Document(xwiki.getXWiki().getDocument("XWiki.${username}", context.context), context.context);
        //userDoc.addObjectFromRequest("XWiki.XWikiUsers"); // TODO: use other explicit values ??
        def userObj = userDoc.getObject("XWiki.XWikiUsers", true);
        userObj.set("password",   password);
        userObj.set("first_name", firstName);
        userObj.set("last_name",  lastName);
        userObj.set("email",      email);
        userObj.set("email",      email);
        userObj.set("member_type",memberType);
        userObj.set("i_agree",   "1");
        if(city) userObj.set("city",       city);
        if(country) userObj.set('country',    country);
        if(state) userObj.set('state', state);
        if(postalCode) userObj.set('postalCode', postalCode)
        if(longitude) userObj.set('longitude', longitude);
        if(latitude) userObj.set('latitutde', latitude);
        userObj.set("show_contact","2"); // Show Your Profile:
        userObj.set("opt_out", 0); //

        userObj.set("country", country);
        userObj.set("city", city);
        userObj.set("state", state);
        userObj.set("postalCode", postalCode);
        userObj.set("longitude", longitude);
        userObj.set("latitude", latitude);

        String language = context.language;
        try {
            if(profile && profile.language) language = profile.language
            if(language!=null && language.indexOf('-')>=0) language = language.substring(0, language.indexOf('-'))
        } catch (Exception ex) {
            LOG.warn("Language \"" + language + "\" incompatible, using " + context.language + " instead.", ex);
            language = context.language;
        };
        Locale locale = new Locale(language);
        userObj.set("language",    locale.getISO3Language());

        // Due to request from Bob at the Teammeeting on the
        // 11th of Feb. 2014 users are always made active after registration
        // and don't have to validate their email anymore
        //
        System.out.println("Making profile active.")
        userObj.set("active", "1");
        userObj.set("email_undeliverable", "0");

        // Old code:
        // activate if from social login, otherwise send mail and put validation key
//        if(profile) {
//            System.out.println("Making profile active.")
//            userObj.set("active", "1");
//            userObj.set("email_undeliverable", "0");
//        } else {
//            System.out.println("Making profile inactive.")
//            userObj.set("active", "0");
//            userObj.set("email_undeliverable", "1");
//            validKey = xwiki.getXWiki().generateValidationKey(16);
//            userObj.set("validkey", validKey);
//            userObj.set("validredirect", request.xredirect);
//        }

        //userdoc.setParent("XWiki.XWikiUsers");
        userDoc.setContent('#include' + 'Form("XWiki.XWikiUserSheet")');
        userDoc.getDoc().setCreator(userDoc.getFullName());
        userDoc.getDoc().setAuthor(userDoc.getFullName());

        // set rights correct (I edit, others view)
        def rightobj = userDoc.newObject("XWiki.XWikiRights");
        rightobj.set("users", new String(username));
        rightobj.set("allow", new String("1"));
        rightobj.set("levels", new String("edit"));
        rightobj.set("groups", new String(""));

        return userDoc;
    }

    public void createSocialLoginProfileObject(Profile profile, Document userDoc, String provider) {
        def socialProfile = userDoc.getObject('XWiki.SocialLoginProfileClass', true)
        socialProfile.set('provider', provider)
        socialProfile.set('fullName', profile.fullName)
        socialProfile.set('firstName', profile.firstName)
        socialProfile.set('lastName', profile.lastName)
        socialProfile.set('displayName', profile.displayName)
        socialProfile.set('email', profile.email)
        socialProfile.set('profileImageURL', profile.profileImageURL)
        socialProfile.set('gender', profile.gender)
        //socialProfile.set('dob', profile.dob) !!! This line raised an error while logging in via facebook, this attribute seems not to be there anymore
        socialProfile.set('validatedId', profile.validatedId)
        socialProfile.set('country', profile.country)
        socialProfile.set('location', profile.location)

        def socialPrefs = userDoc.getObject('XWiki.SocialLoginClass', true)
        socialPrefs.set('preferred_provider', provider)
    }

    public void mergeAccountWithProfile(Profile profile, String userName, String provider) {
        Document userDoc = xwiki.getDocument(userName);
        if(userName.endsWith("XWikiGuest") || userName.startsWith("DeactivatedUsers."))
            throw new IllegalStateException("Can't merge an inactive user!");
        LOG.warn("Trying to merge profile of user "+userName+" with provider's profile from " + provider);

        //createSocialLoginProfileObject(profile, userDoc, provider); Not need anymore the profile object is created while updating the UserDoc

        updateUserDoc(userDoc,true); // We want to merge
        userDoc.saveWithProgrammingRights(msg.get('xwiki.socialLogin.updatedSocialProfile'), true);
        // and login!
        authenticateUser(userDoc);

    }

    /* public String acceptLoginAndRedirect() {
        String xredirect = request.session.getAttribute("xredirect");
        if(xredirect==null || xredirect=="") xredirect = request.getParameter("xredirect");
        if(xredirect==null || xredirect=="") xredirect = "/xwiki/bin/view/" + context.user.replaceAll("\\.","/");
            request.session.setAttribute("xredirect", xredirect);
        nowTarget = xredirect;
        return "redirectOnTop";
    } */

    public String getApplicationApiKey(String provider) {
        provider = provider.toLowerCase();
        if("facebook"==provider)
            return properties.getProperty("graph.facebook.com.consumer_key");
        else if("google"==provider)
            return properties.getProperty("www.google.com.consumer_key");
        else if("yahoo"==provider)
            return properties.getProperty("api.login.yahoo.com.consumer_key");
        else if("twitter"==provider)
            return properties.getProperty("twitter.com.consumer_key");
        else throw new IllegalArgumentException("Unknown provider \"" + provider + "\".");
    }


    public String action(HttpServletRequest request) {
        String a = this.actionHere(request);
        LOG.info("Action: " + a);
        System.out.println("Action: " + a);
        System.out.println("Future target: " + getRedirectTarget(false));
        return a;
    }


    public void echoToConsole() { echoToConsole("");}

    public void echoToConsole(String msg) {
        System.out.print(msg + " This is " + toString() + " with e.g. username " + username);
        if(request!=null)
            System.out.println(" with request to " + request.getRequestURI() + ".");
        else
            System.out.println(" with request to " + request + ".");
    }



    public String actionHere(HttpServletRequest request) {
        if(request.error == "access_denied" && request.error_reason == "user_denied") {
            return "refused";
        }  else if (request.callbackCurriki=="1"){
            return "processAuthReturn";
        } else if(request.code) {
            return "processCleverComAuthArrival";
        } else if(!request.callback && request.provider) {
            return "bounceToProvider";
        } else if(request.xaction && request.xaction=='creationForm')
            return "creationForm";
        else if (request.xaction && request.xaction == 'createProfile') {
            return "createNewProfile";
        }
        else {
            return "nothingToDo";
        }
    }

    private static String SAVED_REQUEST = "org.xwiki.container.servlet.filters.SavedRequestManager.SavedRequest_SavedRequests";

    public String getRedirectTarget(boolean removeMe) {
        if(targets!=null) {
            String target = targets.afterLogin;
            if(removeMe) targets.cleanupTargets();
            return target;
        }
        if(removeMe==null) removeMe = false;
        String xredirect = null;
        if(request.session && request.session.getAttribute(SAVED_REQUEST)) {
            try {
                Object o = request.session.getAttribute(SAVED_REQUEST)
                if(o instanceof Map)
                    xredirect = ((Map) m).value().iterator().next()
                else
                    xredirect = ((org.xwiki.container.servlet.filters.SavedRequestManager.SavedRequest) o).requestUrl;
                if(u && u.length()>0 && removeMe) {
                    request.session.removeAttribute(SAVED_REQUEST);
                    request.session.removeAttribute("xredirect");
                }
            } catch (Exception e) { LOG.warn("Error while getting the saved request from the session ",e); }
        }
        if(xredirect==null && request.session)
            xredirect = request.session.getAttribute("xredirect");
        if(xredirect==null) {
            if(context.user!="XWiki.XWikiGuest")
                xredirect="/xwiki/bin/view/MyCurriki/";
            else
                xredirect="/";
        }
        System.out.println("redirect target is " + xredirect);
        if(removeMe) {
            request.session.removeAttribute("xredirect")
            request.session.removeAttribute(SAVED_REQUEST);
        };
        return xredirect;
    }

    public void tryToAddProfilePictureFromProfile(String url, Document userDoc, com.xpn.xwiki.api.Object userObj) {
        try {
            if(url==null || url.length()==0) return;
            // don't overwrite existing picture
            System.out.println("Defining profile picture form " + url);
            def avatar = userObj.get("avatar");
            if(avatar!=null && !"".equals(avatar)) {
                System.out.println("avatar \"" + avatar + "\" of class " + avatar.getClass() + " already there, leaving quiet.");
                return;
            }else {
                System.out.println("no avatar there (avatar: "+avatar+")!  We're going to get the one from the social authprovier.");
            };
            URL u = new URL(url)
            String name=u.getPath()
            if(name.contains("/")) {
                if(name.endsWith("/") && name.length()>1)
                    name = name.substring(0, name.length()-1);
                name = name.substring(name.lastIndexOf("/")+1);
            }
            HttpClient client = new DefaultHttpClient();
            HttpGet method = new HttpGet(u.toExternalForm());
            HttpResponse response = client.execute(method);
            if(response.getStatusLine().statusCode==200) {
                userDoc.addAttachment(name, response.getEntity().content);
            }
            userObj.set("avatar",name)
        } catch (Exception ex) {
            LOG.warn("Couldn't write profile picture.",ex);
        };

    }

   /**
    * Not in use yet
    **/
    public void tryToAddProfilePictureFromGoogle(){
        try {
            String pictureApiUrl = "https://www.google.com/m8/feeds/photos/profile/curriki.org/felix";
            AuthProvider providerObj = request.session.getAttribute("org.brickred.socialauth.AuthProvider");
            providerObj.verifyResponse(SocialAuthUtil.getRequestParametersMap(request));
            org.brickred.socialauth.util.Response response = providerObj.api(pictureApiUrl, "GET", new HashMap<String, String>(), new HashMap<String, String>(), "");
            System.out.println("Try to load profile Picture from Google.." + response.getResponseBodyAsString("UTF-8").length() );
        } catch (Exception e){
            LOG.warn("Error while loading profile picture from Google: " + e);
        }
    }


    public String getNowTarget() {
        return nowTarget;
    }

    public void sendCorrectConfirmationEmail(isMerging, autoCreateUser) {
        // The mail without password for users taking the normal registration
        if(!isMerging && !autoCreateUser) {
            sendConfirmationEmail();
            System.out.println("Confirmation email sent.");
        }
        // The mail with password for auto registered users (coming from campaign pages)
        else if( (!isMerging && autoCreateUser) ) {
            sendAutoCreatedUserConfirmationEmail();
            System.out.println("Confirmation email for automatic created user sent.");
        }
        // No mail to users using social login and filling in
        // their username and password in the registration form
        else{
            System.out.println("No Confirmation email sent.");
        }
    }

    public void sendConfirmationEmail() {
        sendRegistrationMail("MemberRegCompleteEmail", "CorporateRegCompleteEmail");
    }

    public sendAutoCreatedUserConfirmationEmail() {
        sendRegistrationMail("MemberAutoRegCompleteEmail", "CorporateRegCompleteEmail");
    }




    // ============================== SIMPLE REGISTRATION ===============================

    public boolean readAndValidateQueryParams() {
        username = request.username;
        firstName = request.firstName;
        lastName = request.lastName;
        email = request.email;
        email_confirmation = request.email_confirmation;
        city = request.city;
        country = request.country;
        postalCode = request.postalCode;
        state = request.state;
        longitude = request.longitude;
        latitude = request.latitude;
        password = request.password;
        memberType = request.getParameter("member_type");
        if(memberType==null) memberType="-";

        boolean passed = validation.isValidEmail(email, true);
        passed = validation.isValidEmailConfirmation(email_confirmation, true) & passed;
        passed = validation.isValidUsername(username, true) & passed;
        passed = validation.isValidPassword(password, true) & passed;
        passed = validation.isValidMemberType(memberType, true) & passed;
        passed = validation.isValidAgree(request.agree, true) & passed;
        passed = validation.isValidFirstName(firstName, true) & passed;
        passed = validation.isValidLastName(lastName, true) & passed;
        passed = validation.isValidLocation(country, postalCode, city, state, longitude, latitude, true) & passed;
        return passed;
    }

    public boolean createUser() {
        Document userDoc = createUserDoc();
        userDoc.saveWithProgrammingRights(msg.get('xwiki.socialLogin.updatedSocialProfile'), true)
        //sendValidationEmail();
        sendConfirmationEmail();
        authenticateUser(userDoc);
        return true;
    }

//    When reenabling this method make sure the emails which are sent here
//    are in XWikiSyntax 2 with the velocity macro and html macros used
//    public void sendValidationEmail() {
//        sendRegistrationMail("MemberRegKeySentEmail", "CorporateRegKeySentEmail");
//    }

    private void sendRegistrationMail(String nonCorpPage, String corpPage) {
        long time=System.currentTimeMillis();
        mailsender = xwiki.mailsender;
        def emailDoc = "Registration." + nonCorpPage;
        if(isCorporateAccount())
            emailDoc = "Registration." + corpPage;
        LOG.warn("Sending mail to " + email + " with page " + emailDoc + '.');
        emailDoc = xwiki.getDocument(emailDoc);
        def text = emailDoc.getRenderedContent()
        def subject = xwiki.renderText(emailDoc.title, emailDoc);
        System.out.println("Took: " + (System.currentTimeMillis()-time) + " ms to prepare email body.");
        time=System.currentTimeMillis();

        def from = msg.get("registration.email");
        if(from==null || from=="") from="webmaster@curriki.org";
        if(msg.get("registration.email.name")!="registration.email.name") from = msg.get("registration.email.name") + "<" + from + ">";

        mailsender.sendHtmlMessage(from, email, null, null,
                subject, text, text.replaceAll("<[^>]*>",""), []);
        System.out.println("Took: " + (System.currentTimeMillis()-time) + " ms to send email.");
    }

    public String validateUser() {
        def userdoc = null;
        if(username==null) username = request.getParameter("xwikiname");
        if(username!=null) userdoc = xwiki.getDocument("XWiki." + username);
        if(userdoc==null) return "join.validation.missing-username";
        def userobj = userdoc.getObject("XWiki.XWikiUsers", false);
        if(userobj==null) return "join.validation.missing-username";
        grabFromUserDoc(userdoc);
        def requestKey = request.getParameter("validkey");
        if(requestKey==null || requestKey==""
                || requestKey != userobj.getProperty("validkey").value)
            return "join.validation.missing-key";
        // everything clear let's activate user
        userobj.set("active", "1");
        userobj.set("email_undeliverable", "0");
        userdoc.saveWithProgrammingRights("Validation.");
        // and send registration complete mail
        sendRegistrationMail("MemberRegCompleteEmail", "CorporateRegCompleteEmail");
        authenticateUser(userdoc);
        return "success";
    }

    // ============================== post login... to create the mail again ============
    public void grabFromCurrentUser() {
        username = context.user;
        LOG.info("Grabbing from " + username);
        Document userDoc = xwiki.getDocument(username);
        grabFromUserDoc(userDoc);
    }

    public void grabFromRequestParam() {
        def userdoc = null;
        if(username==null) username = request.getParameter("xwikiname");
        if(username!=null) userdoc = xwiki.getDocument("XWiki." + username);
        if(userdoc!=null) {
            grabFromUserDoc(userdoc);
        }
    }


    private void grabFromUserDoc(Document userDoc) {
        com.xpn.xwiki.api.Object userObj = userDoc.getObject("XWiki.XWikiUsers", false);
        this.firstName = userObj.get("first_name");
        this.lastName = userObj.get("last_name");
        this.validKey = userObj.getProperty("validkey").value;
        this.email = userObj.get("email");
        this.memberType = userObj.getProperty("member_type").value;
    }

    public void setAutoCreateUser(boolean autoCreateUser) {
        this.autoCreateUser = autoCreateUser
    }

    /**
     * Add an url to the queue of the google analytics tracking code
     * put out at analytics.vm.
     * This method is a candidate to get pulled out here and
     * placed into a more general location. For now it rests here.
     *
     * @param page the page to add the the queue
     */
    private void toLogView(String page){
        def currentValue = request.getSession().getAttribute("curriki.analytics.toLogView");

        if(currentValue == null) currentValue = ""

        if(currentValue == "") {
            currentValue += page
        } else {
            currentValue += "," + page
        }
        request.getSession().setAttribute("curriki.analytics.toLogView", currentValue);
    }
}
